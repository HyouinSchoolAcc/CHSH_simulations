import numpy as np
#generate 1 psd matrix 
def generate_psd_matrix_with_eigenvalues():
    random_numbers = np.random.rand(4)
    eigenvalues1=random_numbers/sum(random_numbers)
    #eigenvalues1 = (0.3,0.3,0.2,0.2)
    n = 4
    # Generate random complex eigenvectors
    eigenvectors1 = np.random.rand(n, n) + 1j * np.random.rand(n, n)

    # Construct the PSD matrix using eigendecomposition
    hermitian_matrix1 = np.dot(eigenvectors1, np.diag(eigenvalues1))
    pre_processed_matrix  = np.dot(hermitian_matrix1, np.transpose(np.conjugate(eigenvectors1)))
    
    matrix = pre_processed_matrix/sum(np.linalg.eigvals(pre_processed_matrix))
    return (matrix)

matrix = generate_psd_matrix_with_eigenvalues()
print (np.round(np.linalg.eigvals(matrix),decimals=2))
print (np.round(matrix, decimals=2))

#write the kroniker matrix 
sigma_x = np.array([[0, 1], [1, 0]])
sigma_y = np.array([[0, -1j], [1j, 0]])
sigma_z = np.array([[1, 0], [0, -1]])
identity = np.eye(2)
T_11=np.kron(sigma_x, sigma_x)
T_12=np.kron(sigma_x, sigma_y)
T_13=np.kron(sigma_x, sigma_z)
T_21=np.kron(sigma_y, sigma_x)
T_22=np.kron(sigma_y, sigma_y)
T_23=np.kron(sigma_y, sigma_z)
T_31=np.kron(sigma_z, sigma_x)
T_32=np.kron(sigma_z, sigma_y)
T_33=np.kron(sigma_z, sigma_z)
T = np.zeros((3, 3), dtype=np.complex128)
T[0,0]=np.trace(np.dot(np.array(T_11),np.array(matrix)))
T[0,1]=np.trace(np.dot(np.array(T_12),np.array(matrix)))
T[0,2]=np.trace(np.dot(np.array(T_13),np.array(matrix)))
T[1,0]=np.trace(np.dot(np.array(T_21),np.array(matrix)))
T[1,1]=np.trace(np.dot(np.array(T_22),np.array(matrix)))
T[1,2]=np.trace(np.dot(np.array(T_23),np.array(matrix)))
T[2,0]=np.trace(np.dot(np.array(T_31),np.array(matrix)))
T[2,1]=np.trace(np.dot(np.array(T_32),np.array(matrix)))
T[2,2]=np.trace(np.dot(np.array(T_33),np.array(matrix)))
print (np.round(T, decimals=2))

#Having the coeffeicient of (1/sqrt(2)) will yield the maximum CHSH result of 2.84, but the correct coefficient should be 1/2, what gives?
matrix = (1/np.sqrt(2))*np.array([[1.0,0,0,1.0],[0,0,0,0],[0,0,0,0],[1.0,0,0,1]])
T = np.zeros((3, 3), dtype=np.complex128)
T[0,0]=np.trace(np.dot(np.array(T_11),np.array(matrix)))
T[0,1]=np.trace(np.dot(np.array(T_12),np.array(matrix)))
T[0,2]=np.trace(np.dot(np.array(T_13),np.array(matrix)))
T[1,0]=np.trace(np.dot(np.array(T_21),np.array(matrix)))
T[1,1]=np.trace(np.dot(np.array(T_22),np.array(matrix)))
T[1,2]=np.trace(np.dot(np.array(T_23),np.array(matrix)))
T[2,0]=np.trace(np.dot(np.array(T_31),np.array(matrix)))
T[2,1]=np.trace(np.dot(np.array(T_32),np.array(matrix)))
T[2,2]=np.trace(np.dot(np.array(T_33),np.array(matrix)))
U, s, Vt = np.linalg.svd(T)

# Calculate the eigenvalues
eigenvalues = s ** 2 
print(eigenvalues)

#Some other examples of generated matricies
matrix = (1/2)*np.array([[1.0,0,0,1.0],[0,0,0,0],[0,0,0,0],[1.0,0,0,1]])
T = np.zeros((3, 3), dtype=np.complex128)
T[0,0]=np.trace(np.dot(np.array(T_11),np.array(matrix)))
T[0,1]=np.trace(np.dot(np.array(T_12),np.array(matrix)))
T[0,2]=np.trace(np.dot(np.array(T_13),np.array(matrix)))
T[1,0]=np.trace(np.dot(np.array(T_21),np.array(matrix)))
T[1,1]=np.trace(np.dot(np.array(T_22),np.array(matrix)))
T[1,2]=np.trace(np.dot(np.array(T_23),np.array(matrix)))
T[2,0]=np.trace(np.dot(np.array(T_31),np.array(matrix)))
T[2,1]=np.trace(np.dot(np.array(T_32),np.array(matrix)))
T[2,2]=np.trace(np.dot(np.array(T_33),np.array(matrix)))
U, s, Vt = np.linalg.svd(T)

# Calculate the eigenvalues
eigenvalues = s ** 2 
print(eigenvalues)

matrix = generate_psd_matrix_with_eigenvalues()
T = np.zeros((3, 3), dtype=np.complex128)
T[0,0]=np.trace(np.dot(np.array(T_11),np.array(matrix)))
T[0,1]=np.trace(np.dot(np.array(T_12),np.array(matrix)))
T[0,2]=np.trace(np.dot(np.array(T_13),np.array(matrix)))
T[1,0]=np.trace(np.dot(np.array(T_21),np.array(matrix)))
T[1,1]=np.trace(np.dot(np.array(T_22),np.array(matrix)))
T[1,2]=np.trace(np.dot(np.array(T_23),np.array(matrix)))
T[2,0]=np.trace(np.dot(np.array(T_31),np.array(matrix)))
T[2,1]=np.trace(np.dot(np.array(T_32),np.array(matrix)))
T[2,2]=np.trace(np.dot(np.array(T_33),np.array(matrix)))
U, s, Vt = np.linalg.svd(T)

# Calculate the eigenvalues
eigenvalues = s ** 2 
print(eigenvalues)
